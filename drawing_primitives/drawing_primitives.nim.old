import raylib
import math, sequtils, strutils, options
import ../core/types
export types
type
  # Rect* = object
  #   x*, y*, width*, height*: float32

  Gradient* = object
    startColor*, endColor*: raylib.Color
    vertical*: bool

  Shadow* = object
    blur*: float32
    spread*: float32
    color*: raylib.Color
    offsetX*, offsetY*: float32

# Basic Shapes/Effects


# proc drawRect*(rect: Rect, color: raylib.Color, filled = true)
# Purpose: Draws a rectangle with optional fill.
# Parameters:
#   rect - The rectangle to draw.
#   color - The color of the rectangle.
#   filled - Whether to fill the rectangle (default: true).
# Where to use: In the rendering pipeline, to draw rectangles.

proc drawRect*(rect: Rect, color: raylib.Color, filled = true) =
  ## Draws a rectangle with optional fill
  if filled:
    drawRectangle(
      int32(rect.x),
      int32(rect.y),
      int32(rect.width),
      int32(rect.height),
      color
    )
  else:
    drawRectangleLines(
      int32(rect.x),
      int32(rect.y),
      int32(rect.width),
      int32(rect.height),
      color
    )


# proc drawRoundedRect*(rect: Rect, radius: float32, color: raylib.Color, filled = true)
# Purpose: Draws a rectangle with rounded corners.
# Parameters:
#   rect - The rectangle to draw.
#   radius - The radius of the rounded corners.
#   color - The color of the rectangle.
#   filled - Whether to fill the rectangle (default: true).
# Where to use: In the rendering pipeline, to draw rectangles with rounded corners.
proc drawRoundedRect*(rect: Rect, radius: float32, color: raylib.Color,
    filled = true) =
  ## Draws a rectangle with rounded corners
  let rec = Rectangle(
    x: rect.x,
    y: rect.y,
    width: rect.width,
    height: rect.height
  )
  if filled:
    drawRectangleRounded(rec, radius/min(rect.width, rect.height), 10, color)
  else:
    drawRectangleRoundedLines(rec, radius/min(rect.width, rect.height), 10, 2, color)


# proc drawLine*(x1, y1, x2, y2: float32, color: raylib.Color, thickness = 1.0f32)
# Purpose: Draws a line with specified thickness.
# Parameters:
#   x1, y1 - The starting point of the line.
#   x2, y2 - The ending point of the line.
#   color - The color of the line.
#   thickness - The thickness of the line (default: 1.0).
# Where to use: In the rendering pipeline, to draw lines.
proc drawLine*(x1, y1, x2, y2: float32, color: raylib.Color, thickness = 1.0f32) =
  ## Draws a line with specified thickness
  drawLine(
    Vector2(x: x1, y: y1),
    Vector2(x: x2, y: y2),
    thickness,
    color
  )

# proc drawDashedLine*(x1, y1, x2, y2: float32, dashLen: float32, color: raylib.Color)
# Purpose: Draws a dashed line with specified dash length.
# Parameters:
#   x1, y1 - The starting point of the line.
#   x2, y2 - The ending point of the line.
#   dashLen - The length of each dash.
#   color - The color of the line.
# Where to use: In the rendering pipeline, to draw dashed lines.
proc drawDashedLine*(x1, y1, x2, y2: float32, dashLen: float32, color: raylib.Color) =
  ## Draws a dashed line with specified dash length
  let dx = x2 - x1
  let dy = y2 - y1
  let len = sqrt(dx * dx + dy * dy)
  let angle = arctan2(dy, dx)

  let steps = int32(len / (dashLen * 2))
  let stepX = dx / (steps.float32 * 2)
  let stepY = dy / (steps.float32 * 2)

  for i in 0..<steps:
    let startX = x1 + stepX * (i.float32 * 2)
    let startY = y1 + stepY * (i.float32 * 2)
    let endX = startX + stepX
    let endY = startY + stepY
    drawLine(startX, startY, endX, endY, color)


# proc drawArc*(centerX, centerY, radius: float32, startAngle, endAngle: float32, color: raylib.Color)
# Purpose: Draws an arc (partial circle).
# Parameters:
#   centerX, centerY - The center of the arc.
#   radius - The radius of the arc.
#   startAngle, endAngle - The starting and ending angles of the arc.
#   color - The color of the arc.
# Where to use: In the rendering pipeline, to draw arcs.
proc drawArc*(centerX, centerY, radius: float32,
              startAngle, endAngle: float32, color: raylib.Color) =
  ## Draws an arc (partial circle)
  # Convert angles to radians and normalize
  let startRad = degToRad(startAngle)
  let endRad = degToRad(endAngle)

  # Number of segments based on radius
  let segments = int32(radius / 4) + 8
  let step = (endRad - startRad) / segments.float32

  var points = newSeq[Vector2](segments + 1)
  for i in 0..segments:
    let angle = startRad + step * i.float32
    points[i] = Vector2(
      x: centerX + cos(angle) * radius,
      y: centerY + sin(angle) * radius
    )

  # Draw connected lines
  for i in 0..<points.high:
    drawLine(points[i], points[i + 1], 2, color)



# proc drawPie*(centerX, centerY, radius: float32, startAngle, endAngle: float32, color: raylib.Color)
# Purpose: Draws a pie slice (filled arc).
# Parameters:
#   centerX, centerY - The center of the pie slice.
#   radius - The radius of the pie slice.
#   startAngle, endAngle - The starting and ending angles of the pie slice.
#   color - The color of the pie slice.
# Where to use: In the rendering pipeline, to draw pie slices.
proc drawPie*(centerX, centerY, radius: float32,
              startAngle, endAngle: float32, color: raylib.Color) =
  ## Draws a pie slice (filled arc)
  let center = Vector2(x: centerX, y: centerY)
  let segments = int32(radius / 4) + 8
  let startRad = degToRad(startAngle)
  let endRad = degToRad(endAngle)
  let step = (endRad - startRad) / segments.float32

  var points = newSeq[Vector2](segments + 2)
  points[0] = center # Center point

  for i in 0..segments:
    let angle = startRad + step * i.float32
    points[i + 1] = Vector2(
      x: centerX + cos(angle) * radius,
      y: centerY + sin(angle) * radius
    )

  # Draw triangle fan
  for i in 0..<points.high-1:
    drawTriangle(points[0], points[i + 1], points[i + 2], color)


# proc drawBezier*(points: seq[Point], color: raylib.Color, thickness = 1.0f32) (line 345)
# Purpose: Draws a Bezier curve.
# Parameters:
#   points - The points that define the Bezier curve.
#   color - The color of the curve.
#   thickness - The thickness of the curve (default: 1.0).
# Where to use: In the rendering pipeline, to draw Bezier curves.

proc drawBezier*(x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2: float32,
                 color: raylib.Color, thickness = 2.0f32) =
  ## Draws a cubic Bezier curve
  let steps = 20 # Adjust based on curve length/complexity
  for i in 0..<steps:
    let t1 = i.float32 / steps.float32
    let t2 = (i + 1).float32 / steps.float32

    # First point
    let p1x = pow(1-t1, 3)*x1 + 3*pow(1-t1, 2)*t1*cp1x +
              3*(1-t1)*t1*t1*cp2x + pow(t1, 3)*x2
    let p1y = pow(1-t1, 3)*y1 + 3*pow(1-t1, 2)*t1*cp1y +
              3*(1-t1)*t1*t1*cp2y + pow(t1, 3)*y2

    # Second point
    let p2x = pow(1-t2, 3)*x1 + 3*pow(1-t2, 2)*t2*cp1x +
              3*(1-t2)*t2*t2*cp2x + pow(t2, 3)*x2
    let p2y = pow(1-t2, 3)*y1 + 3*pow(1-t2, 2)*t2*cp1y +
              3*(1-t2)*t2*t2*cp2y + pow(t2, 3)*y2

    drawLine(
      Vector2(x: p1x, y: p1y),
      Vector2(x: p2x, y: p2y),
      thickness,
      color
    )

# proc drawDisabledOverlay*(rect: Rect) (line 356)
# Purpose: Draws a semi-transparent overlay for disabled elements.
# Parameters:
#   rect - The rectangle to draw the overlay in.
# Where to use: In the rendering pipeline, to indicate disabled elements.
proc drawShadow*(rect: Rect, shadow: Shadow) =
  ## Draws a shadow effect under a rectangle
  let blurSteps = 5
  let stepSize = shadow.blur / blurSteps.float32

  for i in 0..<blurSteps:
    let alpha = uint8((255 * (blurSteps - i) / blurSteps))
    let spreadStep = shadow.spread * (i.float32 / blurSteps.float32)
    let shadowColor = raylib.Color(
      r: shadow.color.r,
      g: shadow.color.g,
      b: shadow.color.b,
      a: alpha
    )

    drawRectangle(
      int32(rect.x + shadow.offsetX - spreadStep),
      int32(rect.y + shadow.offsetY - spreadStep),
      int32(rect.width + spreadStep * 2),
      int32(rect.height + spreadStep * 2),
      shadowColor
    )


proc drawGradient*(rect: Rect, gradient: Gradient) =
  ## Draws a linear gradient
  if gradient.vertical:
    drawRectangleGradientV(
      int32(rect.x),
      int32(rect.y),
      int32(rect.width),
      int32(rect.height),
      gradient.startColor,
      gradient.endColor
    )
  else:
    drawRectangleGradientH(
      int32(rect.x),
      int32(rect.y),
      int32(rect.width),
      int32(rect.height),
      gradient.startColor,
      gradient.endColor
    )

type ClipRect* = object
  ## Represents a clipping rectangle
  rect*: Rect
  active*: bool

proc beginClip*(rect: Rect): ClipRect =
  ## Begins a clipping region
  let scissor = Rectangle(
    x: rect.x,
    y: rect.y,
    width: rect.width,
    height: rect.height
  )
  beginScissorMode(
    int32(scissor.x),
    int32(scissor.y),
    int32(scissor.width),
    int32(scissor.height)
  )
  ClipRect(rect: rect, active: true)

proc endClip*(clip: ClipRect) =
  ## Ends a clipping region
  if clip.active:
    endScissorMode()

# Note: drawBlur would require a more complex implementation
# possibly using render textures and shader effects

# Part2:

type
  TextStyle* = object
    fontFamily*: string
    fontSize*: float32
    color*: raylib.Color
    bold*: bool
    italic*: bool
    underline*: bool

  TextAlign* = enum
    Left, Center, Right

  TextLayout* = object
    text*: string
    rect*: Rect
    style*: TextStyle
    align*: TextAlign
    wrap*: bool

  TextMetrics* = object
    width*, height*: float32
    lineHeight*: float32
    baseline*: float32

# Text Measurement and Metrics

proc measureText*(text: string, style: TextStyle): TextMetrics =
  ## Measures text dimensions with given style
  let fontSize = int32(style.fontSize)
  result.width = float32(measureText(text, fontSize))
  result.height = style.fontSize
  result.lineHeight = style.fontSize * 1.2 # Standard line height
  result.baseline = style.fontSize * 0.8 # Approximate baseline

proc measureTextLine*(text: string, style: TextStyle, maxWidth: float32): tuple[
  fits: bool, breakPos: int] =
  ## Measures text and finds word break position if it exceeds width
  var lastSpace = -1
  var currentWidth = 0.0f32

  for i, c in text:
    if c == ' ': lastSpace = i
    currentWidth = measureText(text[0..i], style).width

    if currentWidth > maxWidth:
      return (false, if lastSpace > 0: lastSpace else: i)

  return (true, text.len)

# Basic Text Drawing

proc drawText*(text: string, rect: Rect, style: TextStyle,
    align = TextAlign.Left) =
  ## Draws single-line text with alignment
  let metrics = measureText(text, style)
  var x = rect.x

  case align:
  of TextAlign.Center:
    x = rect.x + (rect.width - metrics.width) / 2
  of TextAlign.Right:
    x = rect.x + rect.width - metrics.width
  else: discard

  # Basic style rendering
  drawText(text, int32(x), int32(rect.y + (rect.height - metrics.height) / 2),
    int32(style.fontSize),
    style.color
  )

  # Underline if needed
  if style.underline:
    let underlineY = rect.y + (rect.height + metrics.height) / 2
    drawLine(
      x, underlineY,
      x + metrics.width, underlineY,
      style.color,
      style.fontSize * 0.05
    )

proc drawTextLayout*(layout: TextLayout) =
  ## Draws multi-line text with wrapping
  var y = layout.rect.y
  let spaceWidth = measureText(" ", layout.style).width
  var currentLine = ""
  var words: seq[string] = layout.text.split(' ')

  while words.len > 0:
    let nextWord = words[0]
    let testLine = if currentLine.len > 0:
                    currentLine & " " & nextWord
                   else:
                    nextWord

    let metrics = measureText(testLine, layout.style)
    if metrics.width <= layout.rect.width:
      currentLine = testLine
      words.delete(0)
    else:
      if currentLine.len > 0:
        # Draw current line
        drawText(currentLine,
                Rect(x: layout.rect.x,
                     y: y,
                     width: layout.rect.width,
                     height: layout.style.fontSize),
                layout.style,
                layout.align)
        y += layout.style.fontSize * 1.2
        currentLine = ""
      else:
        # Word is too long, must split
        currentLine = nextWord
        words.delete(0)

  # Draw last line
  if currentLine.len > 0:
    drawText(currentLine,
            Rect(x: layout.rect.x,
                 y: y,
                 width: layout.rect.width,
                 height: layout.style.fontSize),
            layout.style,
            layout.align)

proc drawEllipsis*(text: string, rect: Rect, style: TextStyle) =
  ## Draws text with ellipsis if it doesn't fit
  const ellipsis = "..."
  let ellipsisWidth = measureText(ellipsis, style).width
  let availableWidth = rect.width - ellipsisWidth

  var fitChars = 0
  var currentWidth = 0.0f32

  for i, c in text:
    let charWidth = measureText($c, style).width
    if currentWidth + charWidth > availableWidth:
      break
    currentWidth += charWidth
    fitChars = i + 1

  if fitChars < text.len:
    let truncated = text[0..<fitChars] & ellipsis
    drawText(truncated, rect, style)
  else:
    drawText(text, rect, style)

# Selection and Cursor

proc drawTextSelection*(rect: Rect, selStart, selEnd: int,
                       text: string, style: TextStyle,
                       selectionColor: raylib.Color) =
  ## Draws text selection highlight
  let startMetrics = measureText(text[0..<selStart], style)
  let selectionMetrics = measureText(text[selStart..<selEnd], style)

  drawRect(
    Rect(
      x: rect.x + startMetrics.width,
      y: rect.y,
      width: selectionMetrics.width,
      height: rect.height
    ),
    selectionColor
  )

  # Draw text on top of selection
  drawText(text, rect, style)

proc drawCursor*(rect: Rect, position: int, text: string,
                style: TextStyle, blinkPhase: float32) =
  ## Draws text cursor with blinking
  if blinkPhase < 0.5:
    let cursorX = rect.x + measureText(text[0..<position], style).width
    drawLine(
      cursorX, rect.y,
      cursorX, rect.y + style.fontSize,
      style.color,
      2.0
    )

# Basic Interactive Elements (that depend on shapes and text)

proc drawCheckmark*(rect: Rect, color: raylib.Color, thickness = 2.0f32) =
  ## Draws a checkmark
  let padding = rect.width * 0.2
  let points = [
    Vector2(x: rect.x + padding,
           y: rect.y + rect.height * 0.5),
    Vector2(x: rect.x + rect.width * 0.4,
           y: rect.y + rect.height * 0.8),
    Vector2(x: rect.x + rect.width - padding,
           y: rect.y + rect.height * 0.2)
  ]

  drawLine(points[0], points[1], thickness, color)
  drawLine(points[1], points[2], thickness, color)

# proc drawRadioCircle*(rect: Rect, selected: bool, color: raylib.Color) (line 394)
# Purpose: Draws a radio button circle.
# Parameters:
#   rect - The rectangle to draw the circle in.
#   selected - Whether the radio button is selected or not.
#   color - The color of the circle.
# Where to use: In the rendering pipeline, to represent a radio button.
proc drawRadioCircle*(rect: Rect, selected: bool, color: raylib.Color) =
  ## Draws a radio button circle
  let center = Vector2(
    x: rect.x + rect.width/2,
    y: rect.y + rect.height/2
  )
  let radius = min(rect.width, rect.height) / 2

  # Outer circle
  drawCircleLines(
    int32(center.x),
    int32(center.y),
    radius,
    color
  )

  # Inner dot if selected
  if selected:
    drawCircle(
      int32(center.x),
      int32(center.y),
      radius * 0.4,
      color
    )

# proc drawRadioCircleWithUnicode(rect: Rect, selected: bool, color: raylib.Color) =
#   ## Draws a radio button circle with Unicode characters
#   let center = Vector2(
#     x: rect.x + rect.width/2,
#     y: rect.y + rect.height/2
#   )
#   let radius = min(rect.width, rect.height) / 2

#   # Outer circle
#   drawCircleLines(
#     int32(center.x),
#     int32(center.y),
#     radius,
#     color
#   )

#   # Inner dot if selected
#   if selected:
#     drawText(
#       if selected: "\u25cf" else: "\u25cb",
#       Vector2(x: center.x, y: center.y),
#       16,
#       color
#   )

# proc drawFocusRing*(rect: Rect, color: raylib.Color) (line 408)
# Purpose: Draws a focus indicator.
# Parameters:
#   rect - The rectangle to draw the focus ring around.
#   color - The color of the focus ring.
# Where to use: In the rendering pipeline, to indicate focus.
proc drawFocusRing*(rect: Rect, color: raylib.Color) =
  ## Draws a focus indicator
  const dashLength = 4.0f32
  drawDashedLine(
    rect.x, rect.y,
    rect.x + rect.width, rect.y,
    dashLength, color
  )
  drawDashedLine(
    rect.x + rect.width, rect.y,
    rect.x + rect.width, rect.y + rect.height,
    dashLength, color
  )
  drawDashedLine(
    rect.x + rect.width, rect.y + rect.height,
    rect.x, rect.y + rect.height,
    dashLength, color
  )
  drawDashedLine(
    rect.x, rect.y + rect.height,
    rect.x, rect.y,
    dashLength, color
  )



# PART 3:

# Interactive Elements



proc fadeColor(color: raylib.Color, factor: float32): raylib.Color =
  return raylib.Color(
    r: uint8(color.r.float32 * factor),
    g: uint8(color.g.float32 * factor),
    b: uint8(color.b.float32 * factor),
    a: color.a)


proc drawScrollbar*(rect: Rect, contentSize, viewSize, offset: float32,
                   color: raylib.Color, hovered = false) =
  ## Draws a scrollbar with thumb
  # Track
  drawRect(rect, color.fadeColor(0.3))

  # Calculate thumb size and position
  let ratio = viewSize / contentSize
  let thumbSize = max(rect.height * ratio, 40.0)       # Minimum thumb size
  let maxOffset = contentSize - viewSize
  let thumbOffset = (rect.height - thumbSize) * (offset / maxOffset)

  # Thumb
  drawRoundedRect(
    Rect(
      x: rect.x,
      y: rect.y + thumbOffset,
      width: rect.width,
      height: thumbSize
    ),
    rect.width / 2,
    if hovered: color else: color.fadeColor(0.8)
  )



proc drawResizeHandle*(rect: Rect, color: raylib.Color) =
  ## Draws a resize handle in the corner
  let size = min(rect.width, rect.height)
  let spacing = size / 4

  for i in 0..2:
    drawLine(
      rect.x + rect.width - spacing * (i.float32 + 1),
      rect.y + rect.height,
      rect.x + rect.width,
      rect.y + rect.height - spacing * (i.float32 + 1),
      color,
      1.0
    )

proc drawRipple*(rect: Rect, center: tuple[x, y: float32],
                 progress: float32, color: raylib.Color) =
  ## Draws a material design style ripple effect
  let maxRadius = sqrt(rect.width * rect.width + rect.height * rect.height)
  let currentRadius = maxRadius * progress

  # Fade out as the circle grows
  let alpha = uint8((1.0 - progress) * 255)
  let rippleColor = raylib.Color(
    r: color.r, g: color.g, b: color.b, a: alpha
  )

  drawCircle(
    int32(center.x),
    int32(center.y),
    currentRadius,
    rippleColor
  )

proc drawProgressBar*(rect: Rect, progress: float32,
                     color: raylib.Color, backgroundColor: raylib.Color) =
  ## Draws a progress bar
  # Background
  drawRoundedRect(rect, rect.height/2, backgroundColor)

  # Progress
  if progress > 0:
    drawRoundedRect(
      Rect(
        x: rect.x,
        y: rect.y,
        width: rect.width * clamp(progress, 0.0, 1.0),
        height: rect.height
      ),
      rect.height/2,
      color
    )

proc drawSpinner*(center: tuple[x, y: float32], radius: float32,
                  rotation: float32, color: raylib.Color) =
  ## Draws a loading spinner
  const segments = 12
  let arcLength = 2.0 * PI * 0.75 # Leave a gap
  let segmentAngle = arcLength / segments.float32

  for i in 0..<segments:
    let alpha = uint8(float32(255) * (i.float32 / segments.float32))
    let segmentColor = raylib.Color(
      r: color.r, g: color.g, b: color.b, a: alpha
    )

    let startAngle = rotation + i.float32 * segmentAngle
    let endAngle = startAngle + segmentAngle * 0.8         # Gap between segments

    drawArc(center.x, center.y, radius,
            radToDeg(startAngle), radToDeg(endAngle),
            segmentColor)

# Decorative Elements

type
  ArrowDirection* = enum
    Up, Down, Left, Right

proc drawArrow*(rect: Rect, direction: ArrowDirection,
                color: raylib.Color, thickness = 2.0f32) =
  ## Draws a directional arrow
  let center = (x: rect.x + rect.width/2, y: rect.y + rect.height/2)
  let size = min(rect.width, rect.height) * 0.4

  var points: array[3, Vector2]
  case direction:
  of Up:
    points = [
      Vector2(x: center.x, y: center.y - size),
      Vector2(x: center.x - size, y: center.y + size),
      Vector2(x: center.x + size, y: center.y + size)
    ]
  of Down:
    points = [
      Vector2(x: center.x, y: center.y + size),
      Vector2(x: center.x - size, y: center.y - size),
      Vector2(x: center.x + size, y: center.y - size)
    ]
  of Left:
    points = [
      Vector2(x: center.x - size, y: center.y),
      Vector2(x: center.x + size, y: center.y - size),
      Vector2(x: center.x + size, y: center.y + size)
    ]
  of Right:
    points = [
      Vector2(x: center.x + size, y: center.y),
      Vector2(x: center.x - size, y: center.y - size),
      Vector2(x: center.x - size, y: center.y + size)
    ]

  drawTriangle(points[0], points[1], points[2], color)

proc drawBadge*(text: string, rect: Rect, color: raylib.Color,
                textColor: raylib.Color, style: TextStyle) =
  ## Draws a notification badge
  let metrics = measureText(text, style)
  let diameter = max(metrics.width + 10, metrics.height + 6)

  # Draw circle background
  drawCircle(
    int32(rect.x + rect.width),
    int32(rect.y),
    diameter/2,
    color
  )

  # Draw text centered in badge
  drawText(
    text,
    Rect(
      x: rect.x + rect.width - diameter/2 - metrics.width/2,
      y: rect.y - diameter/2 - metrics.height/2,
      width: metrics.width,
      height: metrics.height
    ),
    TextStyle(fontSize: style.fontSize, color: textColor)
  )

proc drawTooltip*(text: string, rect: Rect,
                  backgroundColor: raylib.Color, textColor: raylib.Color,
                  style: TextStyle) =
  ## Draws a tooltip with arrow
  let padding = 6.0
  let arrowSize = 5.0
  let metrics = measureText(text, style)
  let tooltipRect = Rect(
    x: rect.x,
    y: rect.y - metrics.height - padding * 2 - arrowSize,
    width: metrics.width + padding * 2,
    height: metrics.height + padding * 2
  )

  # Background
  drawRoundedRect(tooltipRect, 4, backgroundColor)

  # Arrow
  let points = [
    Vector2(x: rect.x + rect.width/2 - arrowSize,
           y: tooltipRect.y + tooltipRect.height),
    Vector2(x: rect.x + rect.width/2 + arrowSize,
           y: tooltipRect.y + tooltipRect.height),
    Vector2(x: rect.x + rect.width/2,
           y: tooltipRect.y + tooltipRect.height + arrowSize)
  ]
  drawTriangle(points[0], points[1], points[2], backgroundColor)

  # Text
  drawText(
    text,
    Rect(
      x: tooltipRect.x + padding,
      y: tooltipRect.y + padding,
      width: tooltipRect.width - padding * 2,
      height: tooltipRect.height - padding * 2
    ),
    TextStyle(fontSize: style.fontSize, color: textColor)
  )

proc drawPlaceholder*(rect: Rect, text: string,
                     style: TextStyle, opacity = 0.5) =
  ## Draws placeholder content with reduced opacity
  let color = raylib.Color(
    r: style.color.r,
    g: style.color.g,
    b: style.color.b,
    a: uint8(255.0 * opacity)
  )

  drawText(
    text,
    rect,
    TextStyle(fontSize: style.fontSize, color: color),
    TextAlign.Center
  )

  # Part 4:

type BStyle = enum
  Solid, Double, Dotted, Dashed
type
  BorderStyle* = object
    color*: raylib.Color
    width*: float32
    radius*: float32
    # For double borders, dotted, etc
    style*: BStyle
    # For 3D effects
    shadowColor*: raylib.Color
    elevation*: float32


  GroupBoxStyle* = object
    borderStyle*: BorderStyle
    titleStyle*: TextStyle
    backgroundColor*: raylib.Color
    titlePosition*: TextAlign
    titlePadding*: float32
    titleBackgroundColor*: Option[raylib.Color] # If you want title bg different from box

proc drawPanel*(rect: Rect, style: BorderStyle,
                backgroundColor: raylib.Color) =
  ## Draws a basic panel with customizable border
  # Draw background
  if style.radius > 0:
    drawRoundedRect(rect, style.radius, backgroundColor)
  else:
    drawRect(rect, backgroundColor)

  # Draw border based on style
  case style.style
  of Solid:
    if style.radius > 0:
      drawRoundedRect(rect, style.radius, style.color, filled = false)
    else:
      drawRectangleLines(
        int32(rect.x),
        int32(rect.y),
        int32(rect.width),
        int32(rect.height),
        style.color
      )
  of Double:
    let inner = Rect(
      x: rect.x + style.width * 2,
      y: rect.y + style.width * 2,
      width: rect.width - style.width * 4,
      height: rect.height - style.width * 4
    )
    drawPanel(rect, BorderStyle(style: Solid, color: style.color,
              width: style.width), backgroundColor)
    drawPanel(inner, BorderStyle(style: Solid, color: style.color,
              width: style.width), backgroundColor)
  of Dotted:
    let perimeter = 2 * (rect.width + rect.height)
    let dotSpacing = 4.0
    let dots = int(perimeter / dotSpacing)
    for i in 0..<dots:
      let pos = i.float32 * perimeter / dots.float32
      var x, y: float32
      if pos < rect.width:
        x = rect.x + pos
        y = rect.y
      elif pos < rect.width + rect.height:
        x = rect.x + rect.width
        y = rect.y + (pos - rect.width)
      elif pos < 2 * rect.width + rect.height:
        x = rect.x + rect.width - (pos - (rect.width + rect.height))
        y = rect.y + rect.height
      else:
        x = rect.x
        y = rect.y + rect.height - (pos - (2 * rect.width + rect.height))
      drawCircle(int32(x), int32(y), style.width/2, style.color)
  of Dashed:
    drawDashedLine(rect.x, rect.y, rect.x + rect.width, rect.y, 8, style.color)
    drawDashedLine(rect.x + rect.width, rect.y, rect.x + rect.width,
                  rect.y + rect.height, 8, style.color)
    drawDashedLine(rect.x + rect.width, rect.y + rect.height, rect.x,
                  rect.y + rect.height, 8, style.color)
    drawDashedLine(rect.x, rect.y + rect.height, rect.x, rect.y, 8, style.color)

  # Draw elevation shadow if needed
  if style.elevation > 0:
    drawShadow(rect, Shadow(
      blur: style.elevation,
      spread: style.elevation * 0.5,
      color: style.shadowColor,
      offsetX: style.elevation * 0.5,
      offsetY: style.elevation * 0.5
    ))

proc drawGroupBox*(rect: Rect, title: string, style: GroupBoxStyle) =
  ## Draws a group box with title
  let metrics = measureText(title, style.titleStyle)
  let titleHeight = metrics.height
  let titleY = rect.y
  let contentY = titleY + titleHeight/2

  # Draw the main box slightly lower to accommodate title
  let boxRect = Rect(
    x: rect.x,
    y: contentY,
    width: rect.width,
    height: rect.height - titleHeight/2
  )
  drawPanel(boxRect, style.borderStyle, style.backgroundColor)

  # Calculate title position
  var titleX = rect.x + style.titlePadding
  case style.titlePosition:
  of Center:
    titleX = rect.x + (rect.width - metrics.width)/2
  of Right:
    titleX = rect.x + rect.width - metrics.width - style.titlePadding
  else: discard

  # Draw title background if specified
  if style.titleBackgroundColor.isSome:
    let titleBgRect = Rect(
      x: titleX - style.titlePadding,
      y: titleY,
      width: metrics.width + style.titlePadding * 2,
      height: titleHeight
    )
    drawRect(titleBgRect, style.titleBackgroundColor.get)

  # Draw title
  drawText(title, Rect(
    x: titleX,
    y: titleY,
    width: metrics.width,
    height: titleHeight
  ), style.titleStyle)

  # "Break" the border where the title is
  let breakWidth = metrics.width + style.titlePadding * 2
  let breakStart = case style.titlePosition:
    of Left: titleX - style.titlePadding
    of Center: titleX - style.titlePadding
    of Right: titleX - style.titlePadding

  drawRect(Rect(
    x: breakStart,
    y: contentY - style.borderStyle.width/2,
    width: breakWidth,
    height: style.borderStyle.width
  ), style.backgroundColor)

proc drawCard*(rect: Rect, style: BorderStyle,
               backgroundColor: raylib.Color) =
  ## Draws a card with optional elevation
  if style.elevation > 0:
    drawShadow(rect, Shadow(
      blur: style.elevation,
      spread: 0,
      color: style.shadowColor,
      offsetX: 0,
      offsetY: style.elevation * 0.5
    ))

  drawRoundedRect(rect, style.radius, backgroundColor)

proc drawDivider*(rect: Rect, color: raylib.Color, vertical = false) =
  ## Draws a simple divider line
  if vertical:
    let x = rect.x + rect.width/2
    drawLine(x, rect.y, x, rect.y + rect.height, color)
  else:
    let y = rect.y + rect.height/2
    drawLine(rect.x, y, rect.x + rect.width, y, color)

# Part 5:
# Status and State Indicators
type Res = enum Success, Error, Warning
proc drawValidationMark*(rect: Rect, state: Res,
                        color: Option[raylib.Color] = none(raylib.Color)) =
  ## Draws validation indicators (checkmark, X, or warning)
  let size = min(rect.width, rect.height)
  let center = (x: rect.x + rect.width/2, y: rect.y + rect.height/2)
  let markColor = if color.isSome: color.get else:
    case state
    of Success: raylib.Color(r: 76, g: 175, b: 80, a: 255)         # Material Green
    of Error: raylib.Color(r: 244, g: 67, b: 54, a: 255)           # Material Red
    of Warning: raylib.Color(r: 255, g: 152, b: 0, a: 255)         # Material Orange

  case state
  of Success:
    # Checkmark
    let points = [
      Vector2(x: center.x - size * 0.3, y: center.y),
      Vector2(x: center.x - size * 0.1, y: center.y + size * 0.2),
      Vector2(x: center.x + size * 0.3, y: center.y - size * 0.2)
    ]
    drawLine(points[0], points[1], 2, markColor)
    drawLine(points[1], points[2], 2, markColor)

  of Error:
    # X mark
    drawLine(
      Vector2(x: center.x - size * 0.3, y: center.y - size * 0.3),
      Vector2(x: center.x + size * 0.3, y: center.y + size * 0.3),
      2, markColor
    )
    drawLine(
      Vector2(x: center.x - size * 0.3, y: center.y + size * 0.3),
      Vector2(x: center.x + size * 0.3, y: center.y - size * 0.3),
      2, markColor
    )

  of Warning:
    # Triangle with exclamation mark
    let points = [
      Vector2(x: center.x, y: center.y - size * 0.3),
      Vector2(x: center.x - size * 0.3, y: center.y + size * 0.3),
      Vector2(x: center.x + size * 0.3, y: center.y + size * 0.3)
    ]
    for i in 0..2:
      drawLine(
        points[i],
        points[(i + 1) mod 3],
        2, markColor
      )
    # Exclamation mark
    drawCircle(int32(center.x), int32(center.y + size * 0.1), 2, markColor)
    drawLine(
      Vector2(x: center.x, y: center.y - size * 0.1),
      Vector2(x: center.x, y: center.y),
      2, markColor
    )
type AlertLevel = enum Info, Alert, Critical
proc drawAlertSymbol*(rect: Rect, style: AlertLevel,
                      color: Option[raylib.Color] = none(raylib.Color)) =
  ## Draws different types of alert symbols
  let size = min(rect.width, rect.height)
  let center = (x: rect.x + rect.width/2, y: rect.y + rect.height/2)
  let symbolColor = if color.isSome: color.get else:
    case style
    of Info: raylib.Color(r: 33, g: 150, b: 243, a: 255)            # Material Blue
    of Alert: raylib.Color(r: 255, g: 152, b: 0, a: 255)            # Material Orange
    of Critical: raylib.Color(r: 244, g: 67, b: 54, a: 255)         # Material Red

  case style
  of Info:
    # Circle with 'i'
    drawCircleLines(int32(center.x), int32(center.y), size/2, symbolColor)
    drawCircle(int32(center.x), int32(center.y - size * 0.2), 2, symbolColor)
    drawLine(
      Vector2(x: center.x, y: center.y - size * 0.1),
      Vector2(x: center.x, y: center.y + size * 0.2),
      2, symbolColor
    )

  of Alert, Critical:
    # Octagon for critical, circle for alert
    if style == Critical:
      var points = newSeq[Vector2](8)
      for i in 0..7:
        let angle = PI/8 + i.float32 * PI/4
        points[i] = Vector2(
          x: center.x + cos(angle) * size/2,
          y: center.y + sin(angle) * size/2
        )
      for i in 0..7:
        drawLine(points[i], points[(i + 1) mod 8], 2, symbolColor)
    else:
      drawCircleLines(int32(center.x), int32(center.y), size/2, symbolColor)

    # Exclamation mark
    drawCircle(int32(center.x), int32(center.y + size * 0.1), 2, symbolColor)
    drawLine(
      Vector2(x: center.x, y: center.y - size * 0.2),
      Vector2(x: center.x, y: center.y),
      2, symbolColor
    )

proc drawBusyIndicator*(rect: Rect, progress: float32, color: raylib.Color) =
  ## Draws an animated busy indicator (similar to macOS style)
  let center = (x: rect.x + rect.width/2, y: rect.y + rect.height/2)
  let radius = min(rect.width, rect.height)/2
  let dotCount = 8
  let dotRadius = radius * 0.15

  for i in 0..<dotCount:
    let angle = progress * PI * 2 + i.float32 * PI * 2 / dotCount.float32
    let x = center.x + cos(angle) * radius
    let y = center.y + sin(angle) * radius
    let alpha = uint8(255.0 * (1.0 - i.float32/dotCount.float32))
    drawCircle(
      int32(x),
      int32(y),
      dotRadius,
      raylib.Color(r: color.r, g: color.g, b: color.b, a: alpha)
    )

proc drawHighlight*(rect: Rect, color: raylib.Color) =
  ## Draws a highlight effect around a rectangle
  const glowSize = 4.0
  for i in 0..<int(glowSize):
    let alpha = uint8(255.0 * (1.0 - i.float32/glowSize))
    let offset = i.float32
    drawRectangleLines(
      int32(rect.x - offset),
      int32(rect.y - offset),
      int32(rect.width + offset * 2),
      int32(rect.height + offset * 2),
      raylib.Color(r: color.r, g: color.g, b: color.b, a: alpha)
    )

proc drawSelectionRect*(rect: Rect, color: raylib.Color) =
  ## Draws a selection rectangle with animated dashed border
  const dashLength = 4.0
  drawDashedLine(rect.x, rect.y, rect.x + rect.width, rect.y, dashLength, color)
  drawDashedLine(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y +
      rect.height, dashLength, color)
  drawDashedLine(rect.x + rect.width, rect.y + rect.height, rect.x, rect.y +
      rect.height, dashLength, color)
  drawDashedLine(rect.x, rect.y + rect.height, rect.x, rect.y, dashLength, color)

proc drawFocusHighlight*(rect: Rect, color: raylib.Color) =
  ## Draws a focus highlight that's more prominent than normal focus ring
  const borderWidth = 2.0
  const glowSize = 3.0

  # Inner border
  drawRectangleLines(
    int32(rect.x),
    int32(rect.y),
    int32(rect.width),
    int32(rect.height),
    color
  )

  # Outer glow
  for i in 1..int(glowSize):
    let alpha = uint8(255.0 * (1.0 - i.float32/glowSize))
    drawRectangleLines(
      int32(rect.x - i.float32),
      int32(rect.y - i.float32),
      int32(rect.width + i.float32 * 2),
      int32(rect.height + i.float32 * 2),
      raylib.Color(r: color.r, g: color.g, b: color.b, a: alpha)
    )

proc drawDisabledOverlay*(rect: Rect) =
  ## Draws a semi-transparent overlay for disabled elements
  drawRect(rect, raylib.Color(r: 128, g: 128, b: 128, a: 128))

# Additional Useful Controls

# proc drawIndeterminateProgress*(rect: Rect, offset: float32, color: raylib.Color) (line 367)
# Purpose: Draws a moving dots progress indicator.
# Parameters:
#   rect - The rectangle to draw the progress indicator in.
#   offset - The offset of the progress indicator.
#   color - The color of the progress indicator.
# Where to use: In the rendering pipeline, to indicate progress.
proc drawIndeterminateProgress*(rect: Rect, offset: float32, color: raylib.Color) =
  ## Draws a moving dots progress indicator
  const dotCount = 5
  const dotSpacing = 20.0
  let dotRadius = rect.height / 3

  for i in 0..<dotCount:
    let phase = (offset + i.float32/dotCount) mod 1.0
    let x = rect.x + phase * rect.width
    let y = rect.y + rect.height/2
    let scale = 1.0 - abs(phase - 0.5) * 2

    drawCircle(
      int32(x),
      int32(y),
      dotRadius * scale,
      color
    )

# proc drawToggleSwitch*(rect: Rect, isOn: bool, color: raylib.Color)
# Purpose: Draws an iOS/Android style toggle switch.
# Parameters:
#   rect - The rectangle to draw the toggle switch in.
#   isOn - Whether the toggle switch is on or off.
#   color - The color of the toggle switch.
# Where to use: In the rendering pipeline, to represent a toggle switch.
proc drawToggleSwitch*(rect: Rect, isOn: bool, color: raylib.Color) =
  ## Draws an iOS/Android style toggle switch
  let height = rect.height
  let width = height * 2
  let radius = height/2
  let thumbRadius = radius * 0.8

  # Track
  drawRoundedRect(
    Rect(x: rect.x, y: rect.y, width: width, height: height),
    radius,
    if isOn: color else: raylib.Color(r: 200, g: 200, b: 200, a: 255)
  )

  # Thumb
  let thumbX = if isOn: rect.x + width - radius else: rect.x + radius
  drawCircle(
    int32(thumbX),
    int32(rect.y + radius),
    thumbRadius,
    White
  )

  # Optional: shadow under thumb
  drawShadow(
    Rect(
      x: thumbX - thumbRadius,
      y: rect.y + radius - thumbRadius,
      width: thumbRadius * 2,
      height: thumbRadius * 2
    ),
    Shadow(
      blur: 4,
      spread: 0,
      color: raylib.Color(r: 0, g: 0, b: 0, a: 64),
      offsetY: 2
    )
  )

proc drawSlider*(rect: Rect, value: float32, color: raylib.Color) =
  ## Draws a horizontal slider
  let height = rect.height
  let trackHeight = height * 0.4
  let thumbRadius = height/2

  # Track
  drawRoundedRect(
    Rect(
      x: rect.x,
      y: rect.y + (height - trackHeight)/2,
      width: rect.width,
      height: trackHeight
    ),
    trackHeight/2,
    raylib.Color(r: 200, g: 200, b: 200, a: 255)
  )

  # Filled part
  drawRoundedRect(
    Rect(
      x: rect.x,
      y: rect.y + (height - trackHeight)/2,
      width: rect.width * value,
      height: trackHeight
    ),
    trackHeight/2,
    color
  )

  # Thumb
  let thumbX = rect.x + rect.width * value
  drawCircle(
    int32(thumbX),
    int32(rect.y + height/2),
    thumbRadius,
    White
  )
  drawCircle(
    int32(thumbX),
    int32(rect.y + height/2),
    thumbRadius * 0.8,
    color
  )


