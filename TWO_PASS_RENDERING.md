# Two-Pass Rendering Architecture

## The Two Passes

### Pass 1: Layout Pass
**Traverse tree, call `updateLayout()` on containers**

- Walk the widget tree
- For each widget, if `layoutDirty == true`:
  - Call `widget.updateLayout()` (only composites have this method)
  - Widget calculates children positions/sizes
  - If bounds changed, mark `isDirty = true` (invalidate render cache)
  - Set `layoutDirty = false`

**Who has `updateLayout()`?**
- **Widgets** (defineWidget) - YES, generated by macro
- **Primitives** (definePrimitive) - NO, they don't do layout

### Pass 2: Render Pass
**Traverse tree, call `render()` on everything**

- Walk the widget tree
- For each widget, if `isDirty == true`:
  - Call `widget.render()`
  - If widget has `cachedTexture`, free it
  - Widget draws to new texture
  - Cache the texture
  - Set `isDirty = false`
- If `isDirty == false`:
  - Use `cachedTexture` (no re-rendering needed!)

**Who has `render()`?**
- **Widgets** (defineWidget) - YES, generated by macro (renders children or decorations)
- **Primitives** (definePrimitive) - YES, generated by macro (draws using primitives)

## The Flow

```
User input or state change
         â†“
Mark widgets layoutDirty or isDirty
         â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      LAYOUT PASS               â•‘
â•‘  Walk tree, call updateLayout()â•‘
â•‘  - Calculate positions         â•‘
â•‘  - Calculate sizes             â•‘
â•‘  - If bounds change â†’ isDirty  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      RENDER PASS               â•‘
â•‘  Walk tree, call render()      â•‘
â•‘  - Draw if isDirty             â•‘
â•‘  - Use cache if clean          â•‘
â•‘  - Store in cachedTexture      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         â†“
Composite to screen
```

## Generated Methods

### definePrimitive (Drawing Atoms)

```nim
definePrimitive(Label):
  props:
    text: string
  render:
    drawText(widget.text, widget.bounds, ...)
```

**Generated**:
```nim
method render*(widget: Label) =
  if not widget.visible: return

  # User's render code
  drawText(widget.text, widget.bounds, ...)

  # Render children (primitives shouldn't have children, but just in case)
  for child in widget.children:
    child.render()
```

**NO `updateLayout()` generated** - primitives don't do layout!

### defineWidget (Composites)

```nim
defineWidget(VStack):
  props:
    spacing: float = 8.0
  layout:
    var y = widget.bounds.y
    for child in widget.children:
      child.bounds.y = y
      y += child.bounds.height + widget.spacing
```

**Generated**:
```nim
method updateLayout*(widget: VStack) =
  if not widget.layoutDirty: return

  # User's layout code
  var y = widget.bounds.y
  for child in widget.children:
    child.bounds.y = y
    y += child.bounds.height + widget.spacing

  widget.layoutDirty = false

method render*(widget: VStack) =
  if not widget.visible: return

  # Default: just render children
  for child in widget.children:
    child.render()
```

## Main Loop

```nim
proc frame(app: App) =
  # Handle input
  let event = pollEvent()
  if event.isSome:
    app.rootWidget.handleInput(event.get())

  # PASS 1: Layout
  if app.rootWidget.layoutDirty or anyChildLayoutDirty(app.rootWidget):
    layoutPass(app.rootWidget)

  # PASS 2: Render
  if app.rootWidget.isDirty or anyChildDirty(app.rootWidget):
    renderPass(app.rootWidget)

  # Composite to screen
  compositeToScreen(app.rootWidget)

proc layoutPass(widget: Widget) =
  ## Recursively update layout for dirty widgets
  if widget.layoutDirty:
    # Only widgets (composites) have updateLayout
    # Primitives skip this
    if widget of CompositeWidget:
      widget.updateLayout()

    widget.layoutDirty = false

  # Recurse to children
  for child in widget.children:
    layoutPass(child)

proc renderPass(widget: Widget) =
  ## Recursively render dirty widgets
  if widget.isDirty:
    # Free old cache
    if widget.cachedTexture.isSome:
      freeTexture(widget.cachedTexture.get())

    # Render to new texture
    let texture = createTexture(widget.bounds.width, widget.bounds.height)
    beginTextureMode(texture)
    widget.render()
    endTextureMode()

    widget.cachedTexture = some(texture)
    widget.isDirty = false

  # Recurse to children
  for child in widget.children:
    renderPass(child)
```

## Cache Invalidation

### When to mark `layoutDirty`:
- Parent container resized
- Children added/removed
- Container properties changed (spacing, padding, etc.)
- Window resized

### When to mark `isDirty`:
- `layoutDirty` was true and bounds changed during layout pass
- Widget state changed (Link[T].set() called)
- Widget properties changed (color, text, etc.)
- Parent marked dirty (optional - could cascade)

## Example: Button Click Changes Label Text

```nim
# 1. User clicks button
button.handleInput(mouseUpEvent)
  â†’ onClick callback fires
  â†’ label.text = "Clicked!"
  â†’ This sets label.isDirty = true

# 2. Next frame starts

# 3. Layout pass
layoutPass(rootWidget)
  â†’ button.layoutDirty? No â†’ skip
  â†’ label.layoutDirty? No â†’ skip
  â†’ No layout changes

# 4. Render pass
renderPass(rootWidget)
  â†’ button.isDirty? No â†’ use cache
  â†’ label.isDirty? Yes!
      â†’ Free old texture
      â†’ Render new text
      â†’ Cache new texture
      â†’ isDirty = false

# 5. Composite to screen
  â†’ Draw button cache
  â†’ Draw label cache (newly rendered)
```

## Example: VStack Spacing Changed

```nim
# 1. User changes spacing
vstack.spacing = 20.0  # was 10.0
  â†’ This should set vstack.layoutDirty = true

# 2. Next frame starts

# 3. Layout pass
layoutPass(vstack)
  â†’ vstack.layoutDirty? Yes!
  â†’ vstack.updateLayout()
      â†’ Recalculate children positions
      â†’ child1.bounds.y = 0
      â†’ child2.bounds.y = 30 (was 20, changed!)
      â†’ child2.isDirty = true (bounds changed)
      â†’ child3.bounds.y = 80 (was 60, changed!)
      â†’ child3.isDirty = true (bounds changed)
  â†’ vstack.layoutDirty = false

# 4. Render pass
renderPass(vstack)
  â†’ vstack.isDirty? No â†’ skip (container doesn't draw)
  â†’ child1.isDirty? No â†’ use cache
  â†’ child2.isDirty? Yes â†’ re-render
  â†’ child3.isDirty? Yes â†’ re-render
```

## Performance Benefits

### Without two-pass:
- Must re-render everything on any change
- Can't cache anything effectively
- Wasted GPU/CPU time

### With two-pass:
- **Layout pass**: Only widgets with `layoutDirty` recalculate
- **Render pass**: Only widgets with `isDirty` re-render
- **Caching**: Clean widgets use `cachedTexture`
- **Minimal work**: Only changed widgets update

### Example Efficiency:
**Scenario**: 1000 widget tree, user clicks button that changes one label

**Without caching**:
- Layout: 1000 widgets (even if nothing moved)
- Render: 1000 widgets (even if nothing changed)

**With two-pass + caching**:
- Layout: ~10 widgets (just the button's ancestors)
- Render: 2 widgets (button + label that changed)
- **99.8% reduction!**

## Macro Responsibilities

### definePrimitive
âœ… Generates `render()` - draws using primitives
âŒ Does NOT generate `updateLayout()` - primitives don't do layout

### defineWidget
âœ… Generates `render()` - renders children (or decorations)
âœ… Generates `updateLayout()` - arranges children

## Implementation Notes

Current macro status:
- âœ… `definePrimitive` only generates `render()`
- âœ… `defineWidget` generates both `updateLayout()` and `render()`
- âœ… Ready for two-pass rendering!

What we need to add:
- Main loop with two passes
- `layoutPass()` function
- `renderPass()` function
- Cache management (create/free textures)
- Dirty tracking helpers

## Summary

**Layout Pass** â†’ Calculate positions, mark dirty if bounds changed
**Render Pass** â†’ Draw dirty widgets, cache results

**Primitives**: Only participate in render pass (draw themselves)
**Widgets**: Participate in both passes (layout children, then render)

**Result**: Efficient rendering, only update what changed! ğŸš€
