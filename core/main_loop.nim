## Main Loop - Two-Pass Rendering
##
## Pass 1: Layout - Calculate positions/sizes, mark dirty if changed
## Pass 2: Render - Draw dirty widgets, use cache for clean ones

import types
import std/algorithm

# ============================================================================
# Dirty Tracking Helpers
# ============================================================================

proc anyChildLayoutDirty*(widget: Widget): bool =
  ## Check if any child (recursively) needs layout
  if widget.layoutDirty:
    return true

  for child in widget.children:
    if child.anyChildLayoutDirty():
      return true

  return false

proc anyChildDirty*(widget: Widget): bool =
  ## Check if any child (recursively) needs rendering
  if widget.isDirty:
    return true

  for child in widget.children:
    if child.anyChildDirty():
      return true

  return false

# ============================================================================
# Pass 1: Layout
# ============================================================================

proc layoutPass*(widget: Widget) =
  ## Recursively update layout for dirty widgets
  ##
  ## This calls layout() via dynamic dispatch.
  ## - Composites (defineWidget) override this to arrange children
  ## - Primitives (definePrimitive) use the base no-op version
  ##
  ## If a widget's bounds change during layout, it's marked isDirty
  ## to trigger re-rendering in the render pass.

  if widget.layoutDirty:
    # Save previous bounds to detect changes
    let oldBounds = widget.bounds

    # Call layout() via dynamic dispatch
    # - Composites have overridden implementation (generated by defineWidget)
    # - Primitives use base Widget version (no-op)
    widget.layout()

    # If bounds changed, mark dirty to trigger re-render
    if widget.bounds != oldBounds:
      widget.isDirty = true

    widget.layoutDirty = false

  # Recurse to children (both primitives and composites can have children)
  for child in widget.children:
    child.layoutPass()

# ============================================================================
# Pass 2: Render
# ============================================================================

proc renderPass*(widget: Widget) =
  ## Recursively render dirty widgets
  ##
  ## Dirty widgets re-render and cache the result.
  ## Clean widgets use their cached texture.
  ##
  ## Both primitives and composites have render() method.

  if not widget.visible:
    return

  if widget.isDirty:
    # Free old cache if present
    if widget.cachedTexture.isSome:
      # TODO: Implement texture freeing when we have GPU backend
      # freeTexture(widget.cachedTexture.get())
      widget.cachedTexture = none(Texture2D)

    # TODO: Render to texture when we have GPU backend
    # For now, just call render() directly (immediate mode)
    widget.render()

    # TODO: Cache the rendered texture
    # let texture = createTexture(widget.bounds.width, widget.bounds.height)
    # beginTextureMode(texture)
    # widget.render()
    # endTextureMode()
    # widget.cachedTexture = some(texture)

    widget.isDirty = false

  # Recurse to children
  # If this widget has overlays, sort children by z-index before rendering
  if widget.hasOverlay and widget.children.len > 1:
    var sortedChildren = widget.children
    sortedChildren.sort(proc(a, b: Widget): int =
      result = cmp(a.zIndex, b.zIndex)  # Ascending: lower z-index renders first
    )
    for child in sortedChildren:
      child.renderPass()
  else:
    # Normal case: render in tree order
    for child in widget.children:
      child.renderPass()

# ============================================================================
# Main Frame Function
# ============================================================================

proc frame*(rootWidget: Widget) =
  ## Execute one frame:
  ## 1. Layout pass (if needed)
  ## 2. Render pass (if needed)
  ##
  ## Call this from your main loop after handling input.

  # Pass 1: Layout
  if rootWidget.layoutDirty or rootWidget.anyChildLayoutDirty():
    rootWidget.layoutPass()

  # Pass 2: Render
  if rootWidget.isDirty or rootWidget.anyChildDirty():
    rootWidget.renderPass()

# ============================================================================
# Usage Example
# ============================================================================

when false:
  # In your main loop:
  proc mainLoop() =
    let rootWidget = createUI()

    while not windowShouldClose():
      # 1. Handle input
      let event = pollEvent()
      if event.isSome:
        rootWidget.handleInput(event.get())

      # 2. Update layout & render (two passes)
      rootWidget.frame()

      # 3. Composite to screen
      # (For now, render() draws directly. Later, composite cached textures)

      # 4. Present
      swapBuffers()
