## DataGrid Widget (Refactored) - Behavior Only
##
## This is the PUBLIC API file - contains only:
## - Props (configuration)
## - State (reactive data)
## - Actions (callbacks)
## - Events (behavior/handlers)
##
## All implementation details are in datagrid_internal.nim

import ../../core/widget_dsl_v2
import std/[options, sets, json]
# import ./datagrid_internal  # Would be auto-imported by enhanced macro

type
  Column* = object
    id*: string
    title*: string
    width*: float32
    sortable*: bool
    formatFunc*: Option[proc(value: JsonNode): string]

  Row* = object
    id*: string
    values*: seq[JsonNode]

  SortOrder* = enum
    soNone
    soAscending
    soDescending

defineWidget(DataGrid):
  ## Sortable data grid with virtual row rendering for large datasets.
  ## See datagrid_internal.nim for implementation details.

  props:
    columns: seq[Column]
    data: seq[Row]
    rowHeight: float = 24.0
    headerHeight: float = 28.0
    showHeader: bool = true
    showGrid: bool = true
    alternateRowColor: bool = true
    gridColor: Color = Color(r: 220, g: 220, b: 220, a: 255)
    altRowColor: Color = Color(r: 245, g: 245, b: 245, a: 255)

  state:
    selected: HashSet[int]
    sortColumn: int = -1
    sortOrder: SortOrder = soNone
    scrollY: float = 0.0
    visibleStart: int = 0
    visibleEnd: int = 0
    hovered: int = -1

  actions:
    onSort(column: int, order: SortOrder)
    onSelect(selected: HashSet[int])
    onDoubleClick(rowIndex: int)

  events:
    ## Event handlers call internal functions for clean separation

    on_mouse_down:
      # Defined in datagrid_internal.nim
      handleDataGridMouseDown(widget)

    on_mouse_wheel:
      # Defined in datagrid_internal.nim
      handleDataGridMouseWheel(widget)

  layout:
    # DataGrid draws directly - no children
    discard

  render:
    # All rendering logic in datagrid_internal.nim
    renderDataGrid(widget)

# Additional public API functions (would be generated by macro)
proc getSelectedRows*(widget: DataGridWidget): seq[Row] =
  ## Get currently selected row data
  result = @[]
  for idx in widget.selected.get():
    if idx >= 0 and idx < widget.data.len:
      result.add(widget.data[idx])

proc clearSelection*(widget: DataGridWidget) =
  ## Clear all selections
  widget.selected.set(initHashSet[int]())
  if widget.onSelect.isSome:
    widget.onSelect.get()(initHashSet[int]())

proc sortByColumn*(widget: DataGridWidget, colIdx: int, order: SortOrder) =
  ## Programmatically sort by column
  widget.sortColumn.set(colIdx)
  widget.sortOrder.set(order)
  if widget.onSort.isSome:
    widget.onSort.get()(colIdx, order)

## Benefits of this refactored approach:
## - Main file is ~100 lines vs ~450 lines (5x smaller!)
## - Clear separation: behavior here, rendering in _internal
## - Easy to understand what the widget does
## - Public API is explicit and documented
## - Testing: mock internal functions for unit tests
## - Maintenance: change rendering without affecting behavior
